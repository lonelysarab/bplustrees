exercise=content.exercises.Dijkstra_Heap
task=<span class="task"/>\n<p>Apply the following Dijkstra's algorithm that solves the single-source shortest-paths problem starting from node A. Graph G = (V,E,W) is represented as an adjacency list.</p>\n<span class="code" name="SSSP-Dijkstra"/>\n<p>SSSP-Dijkstra(G,root) // G = (V,E,W)<br>&nbsp;&nbsp;1 &nbsp;&nbsp;<b>for each</b> u in V<br>&nbsp;&nbsp;2 &nbsp;&nbsp;&nbsp;&nbsp;<b>do</b> u.priority = MAX_VALUE;<br>&nbsp;&nbsp;3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.unvisited = TRUE<br>&nbsp;&nbsp;4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.father = NULL<br>&nbsp;&nbsp;5 &nbsp;&nbsp;root.priority = 0 // root in V<br>&nbsp;&nbsp;6 &nbsp;&nbsp;Q.Insert(root); // Priority Queue Q<br>&nbsp;&nbsp;7 &nbsp;&nbsp;<b>while</b> Q not empty<br>&nbsp;&nbsp;8 &nbsp;&nbsp;&nbsp;&nbsp;<b>do</b> u = DeleteMin(Q)<br>&nbsp;&nbsp;9 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.unvisited = FALSE<br>10 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add edge (u.father, u) into the spanning tree<br>11 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for each</b> (u,v) in E<br>12 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>do if</b> v.unvisited <b>and</b> u.priority + W(u,v) &lt; v.priority<br>13 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>then</b> v.father = u<br>14 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v.priority = u.priority + W(u,v)<br> 15 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.InsertOrUpdate(v)</p>\n<span class="instructions"/>\n<p>Start from the line 6 by inserting the source A into the priority queue (in this case it is a binary heap). The heap operations are described below.</p><p><b>Insert</b> new node by drag & dropping a key from the graph into the heap. The priority (distance from the source) is determined automatically. The priority queue maintains the set of shortest-path estimates, and thus those nodes and their dad-links are shaded.</p><p><b>DeleteMin</b> (the smallest key) from the heap by drag & dropping it into the list labeled "Visiting order". The node is marked visited and colored black, which indicates that it belongs to the set S of vertices whose final shortest-path weights from the source have already determined. The path-length is automatically labeled besides the node.</p><p><b>Update</b> a node if relaxation is needed by selecting the node (either from the heap or graph) and pushing the Update button. Again, the priority is determined automatically - at this time through the last node inserted into S. The new node and its dad-link is shaded and the old ones turn blue.</p>
