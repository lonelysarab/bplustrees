/* 
This file is part of JHAVE -- Java Hosted Algorithm Visualization
Environment, developed by Tom Naps, David Furcy (both of the
University of Wisconsin - Oshkosh), Myles McNally (Alma College), and
numerous other contributors who are listed at the http://jhave.org
site

JHAVE is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your
option) any later version.

JHAVE is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with the JHAVE. If not, see:
<http://www.gnu.org/licenses/>.
*/

package gaigs2;import java.awt.image.*;import java.util.*; import org.jdom.*;public class memorylayout extends StructureType{    // Angle of arrow head sides    private static final double DELTA = (Math.PI/10.0);     // horiz. spacing between ref. boxes as a fraction of the ref box width    private static double hSp;     private boolean debugMode = false;    double adjustedHeight, adjustedWidth;    // Length of arrow head sides    private static final double LENGTH = .025;	           Group grid[][];    int numRows, numCols;    double rowWidth, colWidth, boxWidth;    public memorylayout()    {	super();		// necessary    } // memorylayout()	    /********************************************************************     *     *  loadStructure     *     *******************************************************************/    public void loadStructure(Element rootEl, 			      LinkedList thingsToRender, draw drawerObj)     {	// These two calls load and initialize the name and bounds if	// your xml structure-element has a name and/or bounds like	// the built-in structures.	load_name_and_bounds(rootEl, thingsToRender, drawerObj);	calcDimsAndStartPts(thingsToRender, drawerObj);	// JDOM, AS WE NEED IT, IS EASY TO USE	numRows = Integer.parseInt( rootEl.getAttributeValue("rows") );	numCols = Integer.parseInt( rootEl.getAttributeValue("cols") );		if (rootEl.getAttributeValue("debug_flag").equals("on"))	    debugMode = true;	grid = new Group[numRows][numCols];       	hSp = Double.parseDouble( rootEl.getAttributeValue("horiz_spacing") );	List children = rootEl.getChildren(); // getChildren returns a list	Iterator iter = children.iterator(); // which we will iterate through	//Element nameEl = (Element) iter.next(); // skip "name" child	Element boundsEl = (Element) iter.next(); // skip "bounds" child	/*	double x1 = Double.parseDouble( boundsEl.getAttributeValue("x1") );	double x2 = Double.parseDouble( boundsEl.getAttributeValue("x2") );	double y1 = Double.parseDouble( boundsEl.getAttributeValue("y1") );	double y2 = Double.parseDouble( boundsEl.getAttributeValue("y2") );	*/		if ( (3+4*hSp)*numCols > 5*numRows )	{	    // width is larger than height	    adjustedHeight = 5*numRows / ((3+4*hSp)*numCols);	    adjustedWidth = 1;	}	else	{	    //height is larger than width (2% is left for title)	    adjustedHeight = 0.98;	    adjustedWidth =  0.98* (3+4*hSp)*numCols / (5*numRows);	}   	rowWidth = adjustedHeight / numRows;	colWidth = adjustedWidth / numCols;	boxWidth = colWidth / (3 + 4*hSp) ;	while( iter.hasNext() ) // loop over the groups	{	    Element group = (Element) iter.next(); 	    int row = Integer.parseInt( group.getAttributeValue("row") );	    int col = Integer.parseInt( group.getAttributeValue("col") );	    grid[row][col] = new Group();	    grid[row][col].setRow( row );	    grid[row][col].setCol( col );	    List locations = group.getChildren();	    Iterator iter2 = locations.iterator();	    while ( iter2.hasNext() ) // loop over locations of the group	    {		Element location = (Element) iter2.next();		Element labelElt;		Element boxElt;		Element arrowElt;		if (location.getName().equals("left_ref"))		{   		    /********************************************		     *   current XML node is a LEFT REFERENCE BOX		     ********************************************/		    labelElt = (Element) location.getChild("ref_label");		    boxElt = (Element) location.getChild("box");		    arrowElt = (Element) location.getChild("arrow");		    		    grid[row][col].setLeftLabel( labelElt.getText() );		    grid[row][col].setLeftLabelPosition( 			 labelElt.getAttributeValue( "position" ) );		    grid[row][col].setLeftRef( buildBox( boxElt ) );		    if (arrowElt != null)			grid[row][col].setLeftArrow( buildArrow( arrowElt ) );		    		}		else if (location.getName().equals("middle_ref"))		{   		    /********************************************		     *   current XML node is a MIDDLE REFERENCE BOX		     ********************************************/		    labelElt = (Element) location.getChild("ref_label");		    boxElt = (Element) location.getChild("box");		    arrowElt = (Element) location.getChild("arrow");		    grid[row][col].setMiddleLabel( labelElt.getText() );		    grid[row][col].setMiddleLabelPosition( 			 labelElt.getAttributeValue( "position" ) );		    grid[row][col].setMiddleRef( buildBox( boxElt ) );		    if (arrowElt != null)			grid[row][col].setMiddleArrow( buildArrow( arrowElt));		}		else if (location.getName().equals("right_ref"))		{   		    /********************************************		     *   current XML node is a RIGHT REFERENCE BOX		     ********************************************/		    labelElt = (Element) location.getChild("ref_label");		    boxElt = (Element) location.getChild("box");		    arrowElt = (Element) location.getChild("arrow");		    grid[row][col].setRightLabel( labelElt.getText() );		    grid[row][col].setRightLabelPosition( 			 labelElt.getAttributeValue( "position" ) );		    grid[row][col].setRightRef( buildBox( boxElt ) );		    if (arrowElt != null)			grid[row][col].setRightArrow( buildArrow( arrowElt ) );		}		else if (location.getName().equals("data"))		{   		    /********************************************		     *   current XML node is a DATA BOX		     ********************************************/		    grid[row][col].dataValue = 			location.getAttributeValue( "value" );		    boxElt = (Element) location.getChild("box");		    Box box = new Box(		       boxElt.getAttributeValue("line_color"),		       boxElt.getAttributeValue("line_thickness"),		       boxElt.getAttributeValue("fill_color"));		    grid[row][col].setDataBox( box );		}		else if (location.getName().equals("next"))		{   		    /********************************************		     *   current XML node is a NEXT REFERENCE BOX		     ********************************************/		    boxElt = (Element) location.getChild("box");		    arrowElt = (Element) location.getChild("arrow");		    grid[row][col].setNextRef( buildBox( boxElt ) );		    if (arrowElt != null)			grid[row][col].setNextArrow( buildArrow( arrowElt ) );		}	    }// loop over locations of the current group	} // loop over groups    } // loadStructure    private Box buildBox( Element boxElt )    {	return new Box(		       boxElt.getAttributeValue("line_color"),		       boxElt.getAttributeValue("line_thickness"),		       boxElt.getAttributeValue("fill_color"));    }//buildBox method    private Arrow buildArrow( Element arrowElt )    {	String lineColor = arrowElt.getAttributeValue( "line_color" );	String type = arrowElt.getAttributeValue( "type" );	if (type.equals("regular"))	    return new Arrow(	       Integer.parseInt( arrowElt.getAttributeValue( "row" ) ),	       Integer.parseInt( arrowElt.getAttributeValue( "col" ) ),	       type,	       lineColor );	else	    return new Arrow( -1, -1, type, lineColor ); // NULL arrow    }//buildArrow method    /********************************************************************     *     *  drawStructure     *     *******************************************************************/    public void drawStructure(LinkedList thingsToRender, draw drawerObj)     {	super.drawStructure(thingsToRender, drawerObj);	if (debugMode)	{	/*************************************************************	 *       draw the grid outline	 ************************************************************/	// draw horizontal lines	LGKS.set_textline_color(Green, thingsToRender, drawerObj);	for(int row = 0; row <= numRows; row++)	    LGKS.polyline(2, 			  pair(0.0, adjustedWidth), 			  pair(row*rowWidth,row*rowWidth),			  thingsToRender, drawerObj);	// draw vertical lines	for(int col = 0; col <= numCols; col++)	    LGKS.polyline(2, 			  pair(col*colWidth,col*colWidth),			  pair(0.0, adjustedHeight), 			  thingsToRender, drawerObj);	// draw all boxes	for(int row = 0; row < numRows; row++)	    for(int col = 0; col < numCols; col++)	    {		drawGroupBoxesOutline(row,col, 				      thingsToRender, drawerObj);		drawLabel(			  col*colWidth, row*rowWidth + 0.02*rowWidth,			  (numRows-row-1) + "," + col,				  0.7*boxWidth,			  1,0,			  Green,			  thingsToRender, 			  drawerObj			  );	    }	}	/*************************************************************	 *             draw each visible group in the 2D grid	 *************************************************************/	/*	for(int row = 0; row < numRows; row++)        {	    for(int col = 0; col < numCols; col++)		if ((grid[row][col] !=null) &&                    (grid[row][col].getDataBox() != null))		    System.out.print( "X " );		else		    System.out.print( "  " );	    System.out.println();	}	*/	/* first, draw all of the boxes */	for(int row = 0; row < numRows; row++)	    for(int col = 0; col < numCols; col++)		if (grid[row][col] != null)		    drawGroupBoxes(grid[row][col], thingsToRender, drawerObj);	/* next, draw all black arrows */	int arrowColor = Black;	for(int row = 0; row < numRows; row++)	    for(int col = 0; col < numCols; col++)		if (grid[row][col] != null)		    drawGroupArrows(grid[row][col], arrowColor==Black, thingsToRender, drawerObj);	/* finally, draw all colored arrows */	for(int row = 0; row < numRows; row++)	    for(int col = 0; col < numCols; col++)		if (grid[row][col] != null)		    drawGroupArrows(grid[row][col], arrowColor!=Black, thingsToRender, drawerObj);    }// drawStructure    private void drawGroupBoxesOutline(int row, int col,			   LinkedList thingsToRender, draw drawerObj)     {	row = numRows - row - 1; // puts row 0 on top							double left = col*colWidth;	double bottom = row*rowWidth;	double refBoxBottom = bottom + 3*boxWidth;	double nodeBottom = bottom + boxWidth;	double refLabelBottom = bottom + 4.2*boxWidth;	Box greenBox = new Box( "#00FF00", "regular", "#FFFFFF");	drawBox( greenBox, left + hSp*boxWidth, refBoxBottom, boxWidth, 		 boxWidth, thingsToRender, drawerObj );	drawBox( greenBox, left + (1+2*hSp)*boxWidth, refBoxBottom, 		 boxWidth, boxWidth, thingsToRender, drawerObj );	drawBox( greenBox, left + (2+3*hSp)*boxWidth, refBoxBottom,		 boxWidth, boxWidth, thingsToRender, drawerObj );	drawBox( greenBox, left + 0.5*(1+4*hSp)*boxWidth, nodeBottom,		 boxWidth, boxWidth, thingsToRender, drawerObj );	drawBox( greenBox, left + 0.5*(3+4*hSp)*boxWidth, nodeBottom,		 boxWidth, boxWidth, thingsToRender, drawerObj );    }//drawGroupBoxesOutline method    private void drawGroupBoxes(Group group,			   LinkedList thingsToRender, draw drawerObj)     {	int row = numRows - group.getRow() - 1; // puts row 0 on top	int col = group.getCol();							double left = col*colWidth;	double bottom = row*rowWidth;	double bMargin =  0.3*rowWidth;   // bottom margin	Box leftBox = group.getLeftRef();	Box middleBox = group.getMiddleRef();	Box rightBox = group.getRightRef();	Box dataBox = group.getDataBox();	Box nextBox = group.getNextRef();	double refBoxBottom = bottom + 3*boxWidth;	double nodeBottom = bottom + boxWidth;	double refLabelBottom = bottom + 4.2*boxWidth;	double x1,x2,y1,y2;	int destRow, destCol;	if (debugMode)	{	    Box greenBox = new Box( "#00FF00", "regular", "#FFFFFF");	    drawBox( greenBox, left + hSp*boxWidth, refBoxBottom, boxWidth, 		     boxWidth, thingsToRender, drawerObj );	    drawBox( greenBox, left + (1+2*hSp)*boxWidth, refBoxBottom, 		     boxWidth, boxWidth, thingsToRender, drawerObj );	    drawBox( greenBox, left + (2+3*hSp)*boxWidth, refBoxBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );	    drawBox( greenBox, left + 0.5*(1+4*hSp)*boxWidth, nodeBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );	    drawBox( greenBox, left + 0.5*(3+4*hSp)*boxWidth, nodeBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );	}	if (leftBox != null)	{	    /******************** draw left box **********************/	    drawBox( leftBox, 		     left + hSp*boxWidth, refBoxBottom, boxWidth, boxWidth,		     thingsToRender, drawerObj );	    if (!group.getLeftLabel().equals(""))	    /******************* draw left label *********************/		if (group.getLeftLabelPosition().equals("left"))		    drawLabel(			  left + hSp*boxWidth - 0.005,			  refBoxBottom + 0.3*boxWidth,			  group.getLeftLabel(),				  0.7*boxWidth,			  2,0,			  colorStringToInt(leftBox.getLineColor()),			  thingsToRender, 			  drawerObj			  );		else		    drawLabel(			  left + hSp*boxWidth + 0.5*boxWidth,			  refLabelBottom,			  group.getLeftLabel(),				  0.7*boxWidth,			  0,0,			  colorStringToInt(leftBox.getLineColor()),			  thingsToRender, 			  drawerObj			  );	}	if (middleBox != null)	{	    /******************* draw middle box *********************/	    drawBox( middleBox, 		     left + (1+2*hSp)*boxWidth, refBoxBottom, 		     boxWidth, boxWidth, thingsToRender, drawerObj );	    if (!group.getMiddleLabel().equals(""))            /****************** draw middle label ********************/		if (group.getMiddleLabelPosition().equals("left"))		    drawLabel(			  left + (1+2*hSp)*boxWidth - 0.005,			  refBoxBottom + 0.3*boxWidth,			  group.getMiddleLabel(),				  0.7*boxWidth,			  2,0,			  colorStringToInt(middleBox.getLineColor()),			  thingsToRender, 			  drawerObj			  );		else		    drawLabel(                          left + (1+2*hSp)*boxWidth + 0.5*boxWidth,			  refLabelBottom,			  group.getMiddleLabel(),			  0.7*boxWidth,			  0,0,			  colorStringToInt( middleBox.getLineColor()),			  thingsToRender, 			  drawerObj			  );	} 	if (rightBox != null)	{	    /******************** draw right box *********************/	    drawBox( rightBox,		     left + (2+3*hSp)*boxWidth, refBoxBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );	    if (!group.getRightLabel().equals(""))	                 /****************** draw right label *********************/		if (group.getRightLabelPosition().equals("left"))		    drawLabel(			  left + (2+3*hSp)*boxWidth - 0.005,			  refBoxBottom + 0.3*boxWidth,			  group.getRightLabel(),				  0.7*boxWidth,			  2,0,			  colorStringToInt(rightBox.getLineColor()),			  thingsToRender, 			  drawerObj			  );		else		    drawLabel( 			  left + (2+3*hSp)*boxWidth + 0.5*boxWidth,			  refLabelBottom,			  group.getRightLabel(),			  0.7*boxWidth,			  0,0,			  colorStringToInt( rightBox.getLineColor()),			  thingsToRender, 			  drawerObj			  );	}	/* draw the next box first, unless it is highlighted (not black)*/	if ( (nextBox != null) && (nextBox.getLineColor().equals("#000000")) ) 	    /******************** draw next box **********************/	    drawBox( nextBox,		     left + 0.5*(3+4*hSp)*boxWidth, nodeBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );	if (dataBox != null)	{	    /******************** draw data box **********************/	    drawBox( dataBox,		     left + 0.5*(1+4*hSp)*boxWidth, nodeBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );	    if (!group.getDataValue().equals(""))	     {		 LGKS.set_textline_color(			 	colorStringToInt( dataBox.getLineColor()),				thingsToRender, drawerObj);		 LGKS.set_text_align(0,0,		 		     thingsToRender, drawerObj);		 LGKS.set_text_height(boxWidth,thingsToRender, drawerObj);		 LGKS.text(left + 0.5*(1+4*hSp)*boxWidth + 0.42*boxWidth,			   nodeBottom + 0.2*boxWidth,			   group.getDataValue(), thingsToRender, drawerObj);		 	     }  	}	/* draw the next box after the data box if the formeris highlighted 	   i.e., not black)	*/	if ( (nextBox != null) && (!nextBox.getLineColor().equals("#000000"))) 	    /******************** draw next box **********************/	    drawBox( nextBox,		     left + 0.5*(3+4*hSp)*boxWidth, nodeBottom,		     boxWidth, boxWidth, thingsToRender, drawerObj );    }    private void drawGroupArrows(Group group, boolean wantBlack,			   LinkedList thingsToRender, draw drawerObj)     {	int row = numRows - group.getRow() - 1; // puts row 0 on top	int col = group.getCol();					double left = col*colWidth;	double bottom = row*rowWidth;	double bMargin =  0.3*rowWidth;   // bottom margin	Box leftBox = group.getLeftRef();	Box middleBox = group.getMiddleRef();	Box rightBox = group.getRightRef();	Box dataBox = group.getDataBox();	Box nextBox = group.getNextRef();	double refBoxBottom = bottom + 3*boxWidth;	double nodeBottom = bottom + boxWidth;	double refLabelBottom = bottom + 4.2*boxWidth;	int destRow, destCol;	double coord[] = new double[2];	String arrowColor;	/******************* draw left arrow *********************/	Arrow leftArrow = group.getLeftArrow();	if (leftArrow != null) 	{	    arrowColor = leftArrow.getLineColor();	    if (( wantBlack && arrowColor.equals( "#000000" )) ||		( !wantBlack && !arrowColor.equals( "#000000" )) )	    {		if (leftArrow.getType().equals("null"))		    drawNullRef(left + hSp*boxWidth,   				refBoxBottom,				boxWidth,				colorStringToInt(arrowColor),				thingsToRender, drawerObj);		else		{		    destRow = numRows - 1 - leftArrow.getRow() ;		    destCol = leftArrow.getCol();		    if ( (row == destRow) && (col == destCol) )			drawArrow(left + hSp*boxWidth + 0.5*boxWidth,				  refBoxBottom + 0.5*boxWidth,				  left + 0.5*(1+4*hSp)*boxWidth,				  nodeBottom + boxWidth,				  0.2*boxWidth,				  colorStringToInt(arrowColor),				  thingsToRender, drawerObj);		    else    // arrow pointing to another group		    {			computeDestinationPointFromRef(row,col,destRow,destCol,coord,						       thingsToRender, drawerObj);			drawArrow(                            left + hSp*boxWidth + 0.5*boxWidth,			    refBoxBottom + 0.5*boxWidth,			    coord[0],coord[1],			    0.2*boxWidth,			    colorStringToInt(arrowColor),			    thingsToRender, drawerObj);		    }		}	    }	}	/****************** draw middle arrow ********************/	Arrow middleArrow = group.getMiddleArrow();	if (middleArrow != null)	{	    arrowColor = middleArrow.getLineColor();	    if (( wantBlack && arrowColor.equals( "#000000" )) ||		( !wantBlack && !arrowColor.equals( "#000000" )) )	    {		if (middleArrow.getType().equals("null"))		    drawNullRef(left + (1+2*hSp)*boxWidth,   				refBoxBottom,				boxWidth,				colorStringToInt(arrowColor),				thingsToRender, drawerObj);				else		{ 		    destRow = numRows - 1 - middleArrow.getRow() ;		    destCol = middleArrow.getCol();		    if ( (row == destRow) && (col == destCol) )			drawArrow(left + (1+2*hSp)*boxWidth + 0.5*boxWidth,				  refBoxBottom + 0.5*boxWidth,				  left + 0.5*(1+4*hSp)*boxWidth + 0.5*boxWidth,				  nodeBottom + boxWidth,				  0.2*boxWidth,				  colorStringToInt(arrowColor),				  thingsToRender, drawerObj);		    else    // arrow pointing to another group		    {			computeDestinationPointFromRef(row,col,destRow,destCol,coord,						thingsToRender, drawerObj);			drawArrow(                            left + (1+2*hSp)*boxWidth + 0.5*boxWidth,   			    refBoxBottom + 0.5*boxWidth,			    coord[0], coord[1],			    0.2*boxWidth,			    colorStringToInt(arrowColor),			    thingsToRender, drawerObj);		    }		}	    }	}	/****************** draw right arrow *********************/	Arrow rightArrow = group.getRightArrow();	if (rightArrow != null)	{	    arrowColor = rightArrow.getLineColor();	    if (( wantBlack && arrowColor.equals( "#000000" )) ||		( !wantBlack && !arrowColor.equals( "#000000" )) )	    {		if (rightArrow.getType().equals("null"))		    drawNullRef(left + (2+3*hSp)*boxWidth,   				refBoxBottom,				boxWidth,				colorStringToInt(arrowColor),				thingsToRender, drawerObj);		else		{		    destRow = numRows - 1 - rightArrow.getRow() ;		    destCol = rightArrow.getCol();		    if ( (row == destRow) && (col == destCol) )			drawArrow(	      				  left + (2+3*hSp)*boxWidth + 0.5*boxWidth,   				  refBoxBottom + 0.5*boxWidth,				  left + 0.5*(1+4*hSp)*boxWidth + boxWidth,				  nodeBottom + boxWidth,				  0.2*boxWidth,				  colorStringToInt(arrowColor),				  thingsToRender, drawerObj);		    else    // arrow pointing to another group		    {			computeDestinationPointFromRef(row,col,destRow,destCol,coord,						       thingsToRender, drawerObj);			drawArrow(			    left + (2+3*hSp)*boxWidth + 0.5*boxWidth,   			    refBoxBottom + 0.5*boxWidth,			    coord[0], coord[1],			    0.2*boxWidth,			    colorStringToInt(arrowColor),			    thingsToRender, drawerObj);		    }		}	    }	}// a regular arrow	/******************* draw next arrow *********************/	Arrow nextArrow = group.getNextArrow();	if (nextArrow != null)	{	    arrowColor = nextArrow.getLineColor();	    if 	(( wantBlack && arrowColor.equals( "#000000" )) ||		 ( !wantBlack && !arrowColor.equals( "#000000" )) )	    {		if (nextArrow.getType().equals("null"))		    drawNullRef(left + 0.5*(3+4*hSp)*boxWidth,				bottom + boxWidth,				boxWidth,				colorStringToInt(arrowColor),				thingsToRender, drawerObj);		else	        {		    destRow = numRows - 1 - nextArrow.getRow();		    destCol = nextArrow.getCol();		    if ( (row == destRow) && (col == destCol) )			drawRectangularArrow(                       // center			    left + 0.5*(3+4*hSp)*boxWidth + 0.5*boxWidth,			    0.2*boxWidth,                      // radius			                                       // left			    left + 0.5*(1+4*hSp)*boxWidth + 0.5*boxWidth,			                                       // right			    left + 0.5*(3+4*hSp)*boxWidth + 1.5*boxWidth,  			    bottom + 0.5*boxWidth,             // bottom			    nodeBottom,                        // middle			    nodeBottom+ 0.5*boxWidth,          // top			    colorStringToInt(arrowColor),			    thingsToRender, drawerObj);		    else    // arrow pointing to another group		    {			if ( (destRow == row) && (destCol < col ) )			     drawRectangularArrow(                       // center				left + 0.5*(3+4*hSp)*boxWidth + 0.5*boxWidth,				0.2*boxWidth,                      // radius				                                   // left				destCol*colWidth + 0.5*(1+4*hSp)*boxWidth + boxWidth,				                                   // right				left + 0.5*(3+4*hSp)*boxWidth + 1.5*boxWidth,  				bottom + 0.2*boxWidth,             // bottom				nodeBottom,                        // middle				nodeBottom+ 0.5*boxWidth,          // top				colorStringToInt(arrowColor),				thingsToRender, drawerObj);			else if ( (destRow == row) && (destCol > col+1 ) &&				  (thereIsANodeInBetween(col, destCol, numRows-row-1)) )			    drawRectangularArrow(                       // center				left + 0.5*(3+4*hSp)*boxWidth + 0.5*boxWidth,				0.2*boxWidth,                      // radius				                                   // left				destCol*colWidth + 0.5*(1+4*hSp)*boxWidth + boxWidth,				                                   // right				left + 0.5*(3+4*hSp)*boxWidth + 1.5*boxWidth,  				bottom + 0.2*boxWidth,             // bottom				nodeBottom,                        // middle				nodeBottom+ 0.5*boxWidth,          // top				colorStringToInt(arrowColor),				thingsToRender, drawerObj);			else			{			    computeDestinationPointFromNode(row,col,destRow,destCol,coord,							    thingsToRender, drawerObj);			    drawArrow(				      left + 0.5*(3+4*hSp)*boxWidth + 0.5*boxWidth,				      nodeBottom + 0.5*boxWidth,				      coord[0], coord[1],				      0.2*boxWidth,				      colorStringToInt(nextArrow.getLineColor()),				      thingsToRender, drawerObj);			}		    }		}	    }	}    }    private boolean  thereIsANodeInBetween( int col1, int col2, int row)     {	for(int c = col1 + 1; c < col2; c++)	    if ( (grid[row][c] != null) &&                 (grid[row][c].getDataBox() != null) )				return true;        return false;    }//thereIsANodeInBetween method    private void computeDestinationPointFromNode(int row, int col,						 int destRow, int destCol,						 double coord[],						 LinkedList llist, draw d)    {	// y coordinate	if (destRow > row) // destination is above	    coord[1] = destRow*rowWidth + boxWidth;	else if (destRow < row) // destination is below	    coord[1] = destRow*rowWidth + 2*boxWidth;	else	    coord[1] = destRow*rowWidth + boxWidth + 0.5*boxWidth;	// x coordinate	if (destCol > col) // destination is to the right	    coord[0] = destCol*colWidth + 0.5*(1+4*hSp)*boxWidth;	else if (destCol < col) // destination is to the left	    coord[0] = destCol*colWidth + 0.5*(1+4*hSp)*boxWidth + boxWidth;	else	    coord[0] = destCol*colWidth + 0.5*(1+4*hSp)*boxWidth + 0.5*boxWidth;    }//computeDestinationPointFromRef method    private void computeDestinationPointFromRef(int row, int col,						int destRow, int destCol,						double coord[],						LinkedList llist, draw d)    {	// y coordinate	if (destRow > row) // destination is above	    coord[1] = destRow*rowWidth + boxWidth;	else if (destRow < row) // destination is below	    coord[1] = destRow*rowWidth + 2*boxWidth;	else	    coord[1] = destRow*rowWidth + boxWidth + boxWidth;	// x coordinate	if (destCol > col) // destination is to the right	    coord[0] = destCol*colWidth + 0.5*(1+4*hSp)*boxWidth;	else if (destCol < col) // destination is to the left	    coord[0] = destCol*colWidth + 0.5*(1+4*hSp)*boxWidth + boxWidth;	else	    coord[0] = destCol*colWidth + 0.5*(1+4*hSp)*boxWidth + 0.5*boxWidth;    }//computeDestinationPointFromRef method    private void drawBox( Box box, double left, double bottom,			  double width, double height,			  LinkedList thingsToRender, draw drawerObj)     {	int numPoints = 4;	double xs[] = new double[4];	double ys[] = new double[4];	xs[0] = left;                 ys[0] = bottom;	xs[1] = left + width;         ys[1] = bottom;	xs[2] = left + width;         ys[2] = bottom + height;	xs[3] = left;                 ys[3] = bottom + height;	LGKS.set_fill_int_style(bsSolid,				colorStringToInt( box.getLineColor() ),				thingsToRender, drawerObj);	LGKS.fill_area(numPoints, xs,ys,		       thingsToRender, drawerObj);	LGKS.set_fill_int_style(bsSolid,				colorStringToInt( box.getFillColor() ),				thingsToRender, drawerObj);	if (box.getLineThickness().equals("bold") )	{	    double thickXs[] = new double[4];	    double thickYs[] = new double[4];	    thickXs[0] = left+0.007;        thickYs[0] = bottom+0.006;	    thickXs[1] = left+width-0.0035; thickYs[1] = bottom+0.006;	    thickXs[2] = left+width-0.0035; thickYs[2] = bottom+height-0.0075;	    thickXs[3] = left+0.007;        thickYs[3] = bottom+height-0.0075;	    	    LGKS.fill_area(numPoints, thickXs,thickYs,			   thingsToRender, drawerObj);	}	else	    LGKS.fill_area(numPoints, xs,ys,			   thingsToRender, drawerObj);	// outline	LGKS.set_textline_color(colorStringToInt( box.getLineColor() ),				thingsToRender, drawerObj);	LGKS.polyline(numPoints, xs,ys,  thingsToRender, drawerObj);    } // drawBox method    private void drawLabel(double x, double y, String text,			   double textHeight, int horizAlign, 			   int vertAlign, int color, 			   LinkedList llist, draw d)    {	LGKS.set_textline_color(color, llist, d);	LGKS.set_text_align(horizAlign, vertAlign, llist, d);	LGKS.set_text_height( textHeight, llist, d);	LGKS.text(x,y,text,llist,d);    }//drawLabel method    private double[] pair(double x1, double x2)    { 	double x[] = new double[2];	x[0] = x1;	x[1] = x2;	return x;    }    private void drawNullRef(double left, double bottom, double width, 			     int color, LinkedList llist, draw d)    {	double xs[] = pair( left, left + width);	double ys[] = pair( bottom, bottom + width);	LGKS.set_textline_color(color, llist, d);	LGKS.polyline(2,xs,ys,llist,d);    }    private void drawRectangularArrow( double center, double radius,				  double left, double right,				  double bottom, double middle, double top, 				  int color, LinkedList llist, draw d)    {	LGKS.set_textline_color(color, llist, d);	LGKS.set_fill_int_style(bsSolid, color, llist, d);		LGKS.circle_fill(center, top ,radius,llist,d);	double xs[] = pair( center, right );	double ys[] = pair( top,    top  );	LGKS.polyline(2,xs,ys,llist,d);	xs = pair( right, right );	ys = pair( top,   bottom );	LGKS.polyline(2,xs,ys,llist,d);	xs = pair( right,  left );	ys = pair( bottom, bottom );	LGKS.polyline(2,xs,ys,llist,d);			drawArrow( left, bottom, left, middle, 0, color, llist, d);    }    private void drawArrow(double x1, double y1, double x2, double y2,			   double radius, int color, LinkedList llist, draw d)    {	double xs[] = pair(x1,x2);	double ys[] = pair(y1,y2);	LGKS.set_textline_color(color, llist, d);	LGKS.set_fill_int_style(bsSolid, color, llist, d);	LGKS.polyline(2,xs,ys,llist,d);	LGKS.circle_fill(x1,y1,radius,llist,d);	drawArrowHead(x1,y1,x2,y2,llist,d);    }    // Given the start and end point of the arrow this method will    // draw the arrow head to the specified length and angle.    // The following is not needed anymore since bounds are now square    // NB: The 0.66 and 1.5 factors account for the fact that the    //     bounds are stretched by 50% horizontally    private void drawArrowHead(double x1, double y1, double x2, double y2, 			       LinkedList llist, draw d)    {	double[] triangleX = new double[3];	double[] triangleY = new double[3];	triangleX[0] = x2;   // the tip of the arrow is given	triangleY[0] = y2;	// alpha = the angle (wrt the X-axis) of the REVERSED arrow 	//         -PI/2 <= alpha < 3*PI/2 	// PI is added to reverse the direction of the arrow, BUT ...	// since atan returns a value between -PI/2 and PI/2,	// PI is NOT added to the angle when the arrow points to the left	// to fix 1.5x vert stretching	//double alpha = Math.atan(0.66*(y2-y1)/(x2-x1)); 	double alpha = Math.atan((y2-y1)/(x2-x1));	if (x2-x1 >= 0) alpha += Math.PI;	// angle of edge #1 of the arrow head	double beta1 = alpha + DELTA;	double xshift = LENGTH * Math.cos( beta1 ); 	double yshift = LENGTH * Math.sin( beta1 ); 	//triangleX[1] = x2 + 0.66*xshift;      // same comment	triangleX[1] = x2 + xshift;	triangleY[1] = y2 + yshift;	// angle of edge #2 of the arrow head	double beta2 = alpha - DELTA;	xshift = LENGTH * Math.cos( beta2 ); 	yshift = LENGTH * Math.sin( beta2 ); 	//triangleX[2] = x2 + 0.66*xshift;	// same comment	triangleX[2] = x2 + xshift;	triangleY[2] = y2 + yshift;	LGKS.fill_area(3,triangleX,triangleY,llist,d);    }    /********************************************************************     *     *  inner class: Box     *     *******************************************************************/    class Box    {	String lineColor;	String lineThickness;	String fillColor;		Box()	{	    lineColor = "White";	    lineThickness = "normal";	    fillColor = "White";	}// default constructor	Box (String lc, String lt, String fc)	{	    lineColor = lc;	    lineThickness = lt;	    fillColor = fc;	}// cosntructor	String getLineColor()      { return lineColor; }	String getLineThickness()  { return lineThickness; }	String getFillColor()      { return fillColor;}    }//Box class    /********************************************************************     *     *  inner class: Arrow     *     *******************************************************************/    class Arrow    {	int row, col;       // destination group	String type;        // "regular" or "null"	String lineColor; 	Arrow(int r, int c, String t, String lc)	{	    row = r;	    col = c;	    type = t;	    lineColor = lc;	}// constructor	int getRow()          { return row; }	int getCol()          { return col; }	String getType()      { return type; }	String getLineColor() { return lineColor; }    }//Arrow class    /********************************************************************     *     *  inner class: Group     *     *******************************************************************/    class Group    {	int row, col;	Box leftRef, middleRef, rightRef;	Box dataBox;	String dataValue;	Box nextRef;	String leftLabel, middleLabel, rightLabel;	String leftLabelPosition, middleLabelPosition, rightLabelPosition;	Arrow leftArrow, middleArrow, rightArrow;	Arrow nextArrow;		void setRow( int r )               { row = r; }	void setCol( int c )               { col = c; }	void setLeftRef( Box b )           { leftRef = b; }	void setRightRef( Box b )          { rightRef = b; }	void setMiddleRef( Box b )         { middleRef = b; }	void setDataBox( Box b )           { dataBox = b; }	void setDataValue( String v )      { dataValue = v; }	void setNextRef( Box b )           { nextRef = b; }	void setLeftLabel( String lbl )    { leftLabel = lbl; }	void setMiddleLabel( String lbl )  { middleLabel = lbl; }	void setRightLabel( String lbl )   { rightLabel = lbl; }	void setLeftArrow( Arrow arrow )   { leftArrow = arrow; }	void setRightArrow( Arrow arrow )  { rightArrow = arrow; }	void setMiddleArrow( Arrow arrow ) { middleArrow = arrow; }		void setNextArrow( Arrow arrow )   { nextArrow = arrow; }	void setLeftLabelPosition( String pos )    { leftLabelPosition = pos; }	void setMiddleLabelPosition( String pos ) { middleLabelPosition = pos;}	void setRightLabelPosition( String pos )  { rightLabelPosition = pos; }	int getRow()               { return row; }	int getCol()               { return col; }	Box getLeftRef()           { return leftRef; }	Box getRightRef()          { return rightRef; }	Box getMiddleRef()         { return middleRef; }	Box getDataBox()           { return dataBox; }	String getDataValue()      { return dataValue; }	Box getNextRef()           { return nextRef; }	String getLeftLabel()      { return leftLabel; }	String getMiddleLabel()    { return middleLabel; }	String getRightLabel()     { return rightLabel; }	Arrow getLeftArrow()       { return leftArrow; }	Arrow getRightArrow()      { return rightArrow; }	Arrow getMiddleArrow()     { return middleArrow; }	Arrow getNextArrow()       { return nextArrow; }	String getLeftLabelPosition()      { return leftLabelPosition; }	String getMiddleLabelPosition()    { return middleLabelPosition; }	String getRightLabelPosition()     { return rightLabelPosition; }    }//Group class} // memorymanager class