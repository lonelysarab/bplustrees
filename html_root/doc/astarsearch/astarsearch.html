<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>
<h1>A* Search Algorithm</h1>
<p>The A* Search Algorithm is a fast algorithm for finding the shortest path from a start node to a goal node in a weighted graph that was developed for use in artificial intelligence graph searches. A* makes use of a heuristic function (or quickly computed estimate of the cost to reach the goal from each node), called <i>&#293;</i>, to guide its search. If <i>&#293;</i> underestimates the actual cost to the goal ("the real heuristic," referred to as <i>h</i>), the A* Algorithm is guaranteed to find the shortest possible path from the start node to the goal node. Otherwise, A* follows the "Graceful Decay of Admissibility": If <i>&#293;</i> overestimates <i>h</i> by no more than <i>d</i>, then the A* Algorithm will find a solution with a cost that is no more than <i>d</i> greater than the optimal solution. Thus, an overestimating <i>&#293;</i> function may lead the A* Algorithm to find a less-than-optimal path. However, a heuristic that greatly underestimates the true cost will cause the A* Algorithm to expand more nodes and therefore take longer to find the shortest path. For this reason, one of the foremost challenges in many artificial intelligence graph searches is to develop a heuristic that can be quickly computed and that will provide a very close underestimate of the true cost to the goal.</p>

<p>The A* Algorithm is nearly identical to the Best-First heuristic search algorithm. Like Best-First, A* maintains an open queue of nodes that is sorted in ascending order according to the values of (<i>cost</i>(<i>node</i>) + <i>&#293;</i>(<i>node</i>)). Thus, A* takes both path length and heuristic value into account when deciding which node to close next. For this reason, an inaccurate heuristic can mislead the A* Algorithm to close a node with a greater-than-optimal cost, just like in the Best-First Search Algorithm. However, this is where the A* and Best-First algorithms differ; while Best-First is never able to find the truly optimal path after closing a node with a greater-than-optimal cost, A* can still find the shortest path as long as <i>&#293;</i> underestimates <i>h</i>. Here is a simple example:</p>

<p ALIGN=CENTER>
<IMG SRC="astarsearch.jpg" ALT="Simple Example">
</p>

<p>In the above diagram, when node <i>D</i> is closed, node <i>A</i> will be added to the open queue with a value of (<i>cost</i>(<i>A</i>) = 3 + <i>&#293;</i>(<i>A</i>) = 1), and node <i>C</i> will be added to the open queue with a value of (<i>cost</i>(<i>C</i>) = 1 + <i>&#293;</i>(<i>C</i>) = 4). Since 4 &lt; 5, node <i>A</i> will initially be closed with the greater-than-optimal cost of 3. However, as long as <i>&#293;</i> underestimates <i>h</i>, A* will eventually close node <i>C</i> at which point node <i>A</i> will be removed from the closed list and then will be added to the open queue with the optimal cost of 2. In this way, the A* Algorithm can recover from an errant <i>&#293;</i> function, whereas the Best-First Algorithm would fail to find the optimal path.</p>

<p>This animation shows the execution of the A* Search Algorithm in two ways. On the left, the search graph is displayed with changing node colors to indicate opening and closing nodes (more information on the color-coding appears in the next paragraph). The numbers under the nodes' names are the <i>&#293;</i> values for the nodes, and the numbers along the edges are the edge weights. The right side of the window contains a search tree that is built dynamically to show the progress of the A* Algorithm in searching the graph. The coloring of the tree is coordinated with the coloring of the graph. In the search tree, the numbers under the node names are the costs to reach each node along the current path in the tree. Additionally, the open queue and the closed list are displayed at the top of the viewing window. Open nodes are displayed as <i>node_name(predecessor_name-cost+&#293;)</i>. Therefore, the nodes in the open queue are ordered by the sum of these numbers inside the parentheses (with alphabetical order used to break ties). The closed nodes are presented in a similar format, with the closing node's name appearing first followed by (in parentheses) the name of the node's predecessor and the current closing cost of the node. Furthermore, the pseudocode window tracks the algorithm by highlighting the section of code that produced the most recent change in the animation.</p>

<p>The coloring scheme is used to highlight open and closed nodes and also shows recent changes in executing the A* Algorithm. The <b><font color=#44FF44>darker green</b></font color=#44FF44> node in the graph and tree indicates the node that has just been closed in the current loop. The <b><font color=#AAFFAA>paler green</b></font color=#AAFFAA> nodes are nodes that have been closed in previous loops. <b><font color=#00A1F4>Darker blue</b></font color=#00A1F4> nodes are nodes that have just been added to the open queue in the current loop. Notice that these nodes will always be connected directly to the <b><font color=#44FF44>darker green</b></font color=#44FF44> node by an edge. Nodes that have faded to a <b><font color=#88E6F4>paler hue of blue</b></font color=#88E6F4> are nodes that are still on the open queue but were added in previous loops. In this way, the blue nodes (both <b><font color=#00A1F4>dark</b></font color=#00A1F4> and <b><font color=#88E6F4>light</b></font color=#88E6F4>) in the search tree comprise the entire open queue, making it easy to find the path to the next node that will be closed. When a node in the tree turns <b><font color=#FF3232>red</b></font color=#FF3232>, the A* Algorithm has just taken that node off the closed list and placed it back onto the open queue with an updated cost. These <b><font color=#FF3232>red</b></font color=#FF3232> nodes will fade to a <b><font color=#FFA9A9>paler shade</b></font color=#FFA9A9> after the loop in which they are re-expanded. Since a node can be added to the open queue from multiple predecessors, a node sometimes is added to the open queue multiple times. When the duplicate node with the lowest cost is taken off the open queue and closed, the other duplicate nodes remain in the open queue until they are removed from the front. When an already-closed node is taken off the open queue in this manner, the search tree removes the <b><font color=#88E6F4>blue shading</b></font color=#88E6F4> from this node, indicating that it is no longer in the open queue. Finally, when a node is closed, the current shortest path to the closing node's predecessor in the graph is highlighted in <b><font color=#FFFF00>yellow</b></font color=#FFFF00> to show the current path being probed in the search graph.</p>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3174792-1";
urchinTracker();
</script>
</body>
</html>
